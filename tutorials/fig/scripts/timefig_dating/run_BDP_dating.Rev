
#######################
# INITIALIZE SETTINGS # 
#######################

# RNG seed
if (!exists("my_seed"))           my_seed = 1
seed(my_seed)


# Toggle a default settings with `!`, e.g. `!true` is `false`
# The analysis filename will indicate non-default settings
if (!exists("init_parameters"))   init_parameters  = true

if (!exists("use_bg_calib"))      use_bg_calib     = false
if (!exists("use_root_calib"))    use_root_calib   = true
if (!exists("under_prior"))       under_prior      = false

if (!exists("use_mol"))           use_mol          = true
if (!exists("update_topology"))   update_topology  = false
if (!exists("move_schedule"))     move_schedule    = v("random","single")[1]

# dataset constraints
if (!exists("num_loci"))          num_loci = 10

# analysis string name
analysis                                    = "BDP_dating"
if (!use_root_calib)              analysis += "_noRootCalib"
if (use_bg_calib)                 analysis += "_yesBgCalib"
if (under_prior)                  analysis += "_underPrior"
analysis += ".seed" + my_seed

print("Analysis name: ", analysis)

# analysis settings
n_proc          = 6
n_iter          = 10000
print_gen       = 10

# filesystem
clade_name    = "kadua"
fp            = "./"
dat_fp        = fp + "data/clade/"
geo_fp        = fp + "data/geo/"
mol_fp        = dat_fp + "/genes/"
code_fp       = fp + "scripts/timefig_dating/"
calib_fn      = dat_fp + clade_name + "_calib.csv"
phy_fn        = dat_fp + clade_name + ".tre"

# model source code
mol_code_fn   = code_fp + "mol_timeFIG.Rev"
phylo_code_fn = code_fp + "phylo_BDP.Rev"
clade_fn      = code_fp + "clade.Rev"

# get phylogenetic data
phy          <- readTrees(phy_fn)[1]
phy.rescale( 5./phy.rootAge() )
tree_height  <- phy.rootAge()
taxa         = phy.taxa()
num_taxa     = taxa.size()
num_branches = 2 * num_taxa - 2

# get molecular data
mol_idx       = [ 5339, 5398, 5513, 5664, 6038, 6072, 6238, 6265, 6439, 6500, 6527, 6550, 6552, 6791, 6848, 6978, 7013, 7021, 7111 ]
for (i in 1:mol_idx.size()) {
    mol_fn[i] = mol_fp + "clean_" + mol_idx[i] + "_supercontig.nexus"
}
for (i in 1:num_loci) {
    dat_mol[i] = readDiscreteCharacterData(mol_fn[i])
    num_sites[i] = dat_mol[i].nchar()
}

#subset the molecular alignments to match the taxa in the tree
# get the names of taxa on the tree
for(i in 1:taxa.size()) {
    taxa_names[i] = taxa[i].getName()
}
# first, exclude all taxa
for(i in 1:num_loci) {
    dat_mol[i].excludeTaxa(dat_mol[i].taxa())
}
# now, include taxa in the tree
for(i in 1:num_loci) {
    dat_mol[i].includeTaxa(taxa_names)
}
# make sure we include missing data (add taxa that are missing in the alignment but appear in the tree)
for(i in 1:num_loci) {
    dat_mol[i].addMissingTaxa(taxa_names)
}

# get calibration data
if (use_root_calib) {
    dat_calib = readDataDelimitedFile(file=calib_fn, header=true, separator=",", rownames=false)
}

# load ingroup clade info
source(clade_fn)

# load phylogeny model script
source( phylo_code_fn )

# associate phylo/biogeo data with model
timetree.setValue(phy)

# load molecular model script
if (use_mol) {
    source( mol_code_fn )
    for (i in 1:num_loci) {
        x_mol[i].clamp(dat_mol[i])
    }
}

print("Creating moves...")

# create moves
moves = VectorMoves()

# tree variable moves
if (update_topology) {
    moves.append( mvNNI(timetree, weight=num_taxa) )
    moves.append( mvFNPR(timetree, weight=num_taxa/4) )
}
moves.append( mvNodeTimeSlideUniform(timetree, weight=2*num_taxa) )
moves.append( mvScale(root_age, weight=15) )
#moves.append( mvNodeTimeScale(timetree, weight=num_taxa) )


# molecular moves
    
# base rate of molecular substitutioni
moves.append(mvScale(mu_mol_base, weight=5) )

# branch rates of molecular substitution, centered on mu_mol_base
for (i in 1:num_branches) {
    moves.append(mvScale(mu_mol_branch[i], weight=1))
}

for (i in 1:num_loci) {
    if (i >= 2) {
        moves.append(mvScale(mu_mol_locus_rel[i], weight=3))
    }
    moves.append(mvScale(kappa[i], weight=3))
    moves.append(mvScale(alpha[i], weight=3))
    moves.append(mvSimplex(pi_mol[i], alpha=3, offset=0.5, weight=3))
}

# joint moves
up_down_scale_tree = mvUpDownScale(lambda=1.0, weight=20)
up_down_scale_tree.addVariable(timetree,      up=true)
up_down_scale_tree.addVariable(root_age,      up=true)
up_down_scale_tree.addVariable(mu_mol_branch, up=false)
up_down_scale_tree.addVariable(mu_mol_base,   up=false)
moves.append(up_down_scale_tree)

up_down_mol_rate = mvUpDownScale(lambda=1.0, weight=20)
up_down_mol_rate.addVariable(mu_mol_branch, up=true)
up_down_mol_rate.addVariable(mu_mol_base,   up=true)
moves.append(up_down_mol_rate)

# MJL: this seems to cause a bug, working to fix w/ Mike May
rate_age_proposal = mvRateAgeProposal(timetree, weight=20, alpha=5)
rate_age_proposal.addRates(mu_mol_branch)
moves.append(rate_age_proposal)




############
# Monitors #
############

print("Creating monitors...")
# create monitor vector
monitors = VectorMonitors()
# screen monitor, so you don't get bored
monitors.append( mnScreen(root_age, printgen=print_gen) )
# file monitor for all simple model variables
monitors.append( mnModel(printgen=print_gen, file="output/" + analysis + ".model.txt") )
# file monitor for tree
monitors.append( mnFile(timetree, printgen=print_gen, file="output/" + analysis + ".tre") )
# file monitor for molecular model
if (use_mol) {
    monitors.append( mnFile(mu_mol_base, mu_mol_branch, mu_mol_locus_rel, alpha, kappa, root_age, printgen=print_gen, file="output/" + analysis + ".mol.txt") )
}

# create model object
print("Creating model...")
mymodel = model(timetree)

# create MCMC object
print("Creating MCMC...")
mymcmc = mcmc(mymodel, moves, monitors, moveschedule=move_schedule)
mymcmc.operatorSummary()

# run MCMC
print("Running MCMC...")
mymcmc.run(n_iter, underPrior=under_prior)

# done!
quit()
