
####################################################
# IMPORTANT: set `tensorphylo_fp` to the directory #
# containing your `libTensorPhylo.a/dylib` library #
####################################################
#tensorphylo_fp = "/home/ilichtermarck/.plugins"
#tensorphylo_fp = "/usr/lib/x86_64-linux-gnu"


use_dirty = !false
tensorphylo_fp = "/Users/mlandis/.local/lib/tensorphylo"
#tensorphylo_fp = "/home/mlandis/.local/lib/tensorphylo"
if (!exists("tensorphylo_fp")) {
  tensorphylo_fp = "~/.plugins/"
}

loadPlugin("TensorPhylo", tensorphylo_fp)

#######################
# INITIALIZE SETTINGS # 
#######################


# Main analysis settings
# Toggle a default settings with `!`, e.g. `!true` is `false`
# The analysis filename will indicate non-default settings
if (!exists("init_parameters"))   init_parameters  = true

if (!exists("use_features"))      use_features     = !true
if (!exists("use_paleogeo"))      use_paleogeo     = true
if (!exists("use_bg_calib"))      use_bg_calib     = false
if (!exists("use_root_calib"))    use_root_calib   = !true
if (!exists("under_prior"))       under_prior      = false

if (!exists("use_rj"))            use_rj           = true
if (!exists("use_mol"))           use_mol          = true
if (!exists("use_subset"))        use_subset       = false
if (!exists("update_topology"))   update_topology  = false
if (!exists("move_schedule"))     move_schedule    = v("random","single")[1]

# benchmarking
if (!exists("rel_tol")) rel_tol = 1e-7
if (!exists("abs_tol")) abs_tol = 1e-7
if (!exists("time_benchmark")) time_benchmark = false

# move settings
if (!exists("rho_d_init"))   rho_d_init   = 0.1
if (!exists("rho_e_init"))   rho_e_init   = 0.1
if (!exists("rho_w_init"))   rho_w_init   = 0.1
if (!exists("rho_b_init"))   rho_b_init   = 0.1
if (!exists("phi_d_init"))   phi_d_init   = 0.0
if (!exists("phi_e_init"))   phi_e_init   = 0.0
if (!exists("phi_w_init"))   phi_w_init   = 0.0
if (!exists("phi_b_init"))   phi_b_init   = 0.0
if (!exists("sigma_d_init")) sigma_d_init = 0.0
if (!exists("sigma_b_init")) sigma_b_init = 0.0
if (!exists("sigma_e_init")) sigma_e_init = 0.0
if (!exists("sigma_w_init")) sigma_w_init = 0.0
if (!exists("max_subrange_split_size")) max_subrange_split_size = 100
if (!exists("max_range_size")) max_range_size = 4
if (!exists("num_loci")) num_loci = 10

# RNG seed
if (!exists("my_seed")) my_seed = 12
if (!exists("clade_name")) clade_name = "kadua"
if (!exists("model_name")) model_name = ""
seed(my_seed)
print("My seed is " + my_seed)

# analysis string name
analysis = "Kadua"
if (model_name != "") analysis  += "_" + model_name
if (!use_features) analysis     += "_noFeatures"
if (!use_root_calib) analysis   += "_noRootCalib"
if (use_bg_calib) analysis      += "_yesBgCalib"
if (!use_paleogeo) analysis     += "_noPaleogeo"
if (under_prior) analysis       += "_underPrior"
if (!use_mol) analysis          += "_noMolecular"
if (!use_rj) analysis           += "_noRjmcmc"
#if (use_dirty) analysis         += "_useDirty"
analysis += "_" + my_seed
print("Analysis name: ", analysis)

# analysis settings
n_proc    = 6
n_iter    = 10000
print_gen = 1
stoch_print_gen = 20

# filesystem
fp            = "./"
dat_fp        = fp + "data/"
geo_fp        = dat_fp + "realistic/"
feature_fn    = geo_fp + "feature_summary.csv"
bg_fp         = dat_fp + clade_name + "_data/"
mol_fp        = dat_fp + clade_name + "_data/genes/"
calib_fn      = bg_fp + clade_name + "_calib.csv"
phy_fn        = bg_fp + clade_name + "_chronos_outgroups.tree"
bg_fn         = bg_fp + clade_name + "_range_outgroups.nex"

mol_idx       = [ 5339, 5398, 5513, 5664, 6038, 6072, 6238, 6265, 6439, 6500, 6527, 6550, 6552, 6791, 6848, 6978, 7013, 7021, 7111 ]
for (i in 1:mol_idx.size()) {
    mol_fn[i] = mol_fp + "clean_" + mol_idx[i] + "_supercontig.nexus"
}
#mol_fn        = [ mol_fp + "clean_6038_supercontig.nexus",
#                  mol_fp + "clean_6072_supercontig.nexus",
#                  mol_fp + "clean_6550_supercontig.nexus",
#                  mol_fp + "clean_6552_supercontig.nexus" ]

geo_code_fn   = fp + "code/geo_timeFIG.Rev"
mol_code_fn   = fp + "code/mol_multi_timeFIG.Rev"
phylo_code_fn = fp + "code/phylo_timeFIG.Rev"
clade_fn      = fp + "code/clade.Rev"
subset        = fp + "code/subset.Rev"
label_fn      = bg_fp + clade_name + "_range_label.csv"

# model settings

# get phylogenetic data
phy          <- readTrees(phy_fn)[1]
phy.rescale( 5./phy.rootAge() )
tree_height  <- phy.rootAge()
taxa         = phy.taxa()
num_taxa     = taxa.size()
num_branches = 2 * num_taxa - 2

# get biogeographic data
dat_01       = readDiscreteCharacterData(bg_fn)
num_regions  = dat_01.nchar()
num_ranges   = 0
for (k in 1:max_range_size) {
    num_ranges += choose(num_regions, k)
}

#num_ranges   = abs(2^num_regions - 1)
dat_nn       = formatDiscreteCharacterData(dat_01, format="GeoSSE", numStates=num_ranges)
desc         = dat_nn.getStateDescriptions()

write("index,range\n", filename=label_fn)
for (i in 1:desc.size()) {
    write((i-1) + "," + desc[i] + "\n", filename=label_fn, append=true)
}

# get molecular data
#num_loci = mol_fn.size()
num_taxa = taxa.size()
for (i in 1:num_loci) {
    dat_mol[i] = readDiscreteCharacterData(mol_fn[i])
    num_sites[i] = dat_mol[i].nchar()
}

#subset the molecular alignments to match the taxa in the tree
# get the names of taxa on the tree
for(i in 1:taxa.size()) {
    taxa_names[i] = taxa[i].getName()
}
# first, exclude all taxa
for(i in 1:num_loci) {
    dat_mol[i].excludeTaxa(dat_mol[i].taxa())
}
# now, include taxa in the tree
for(i in 1:num_loci) {
    dat_mol[i].includeTaxa(taxa_names)
}
# make sure we include missing data (add taxa that are missing in the alignment but appear in the tree)
for(i in 1:num_loci) {
    dat_mol[i].addMissingTaxa(taxa_names)
}

# get calibration data
if (use_root_calib) {
    dat_calib = readDataDelimitedFile(file=calib_fn, header=true, separator=",", rownames=false)
}

# load ingroup clade info
source(clade_fn)

#load subset script
if (use_subset){
	source( subset )
}

# load geography model script
source( geo_code_fn )

# load phylogeny model script
source( phylo_code_fn )

# associate phylo/biogeo data with model
timetree.setValue(phy)
timetree.clampCharData(dat_nn)
#timetree.getCharData().show()



print("Compute Tensorphylo model probability...")
timetree.lnProbability()
print("...done!")


if (time_benchmark) {
    num_compute = 30
    start_time = time()
    for (i in 1:num_compute) {
        root_age.setValue(root_age * 1.00001)
        lnP = timetree.lnProbability()
    }
    end_time = time()
    diff_time = (end_time - start_time) / num_compute
    fn = "./benchmark.csv"
    write(rel_tol, abs_tol, lnP, diff_time, file=fn, separator=",", append=true)
    write("\n", file=fn, append=true)
    quit()
}


# load molecular model script
if (use_mol) {
    source( mol_code_fn )
    for (i in 1:num_loci) {
        x_mol[i].clamp(dat_mol[i])
    }
}

print("Creating moves...")

# create moves
moves = VectorMoves()

# tree variable moves
if (update_topology) {
    moves.append( mvNNI(timetree, weight=num_taxa) )
    moves.append( mvFNPR(timetree, weight=num_taxa/4) )
}
moves.append( mvNodeTimeSlideUniform(timetree, weight=2*num_taxa) )
moves.append( mvScale(root_age, weight=15) )
#moves.append( mvNodeTimeScale(timetree, weight=num_taxa) )

moves.append( mvScale(rho_d, weight=5) )
moves.append( mvScale(rho_e, weight=5) )
moves.append( mvScale(rho_w, weight=5) )
moves.append( mvScale(rho_b, weight=5) )

if (use_features) {
    for (i in 1:sigma_e.size()) {
        moves.append( mvScale(sigma_e[i], weight=2) )
        moves.append( mvScale(sigma_w[i], weight=2) )
        moves.append( mvSlide(sigma_e[i], weight=2) )
        moves.append( mvSlide(sigma_w[i], weight=2) )
        if (use_rj) {
            moves.append( mvRJSwitch(sigma_e[i], weight=3) )
            moves.append( mvRJSwitch(sigma_w[i], weight=3) )
            use_sigma_e[i] := ifelse(sigma_e[i] == 0.0, 0, 1)
            use_sigma_w[i] := ifelse(sigma_w[i] == 0.0, 0, 1)
        }
    }
    for (i in 1:sigma_d.size()) {
        moves.append( mvScale(sigma_d[i], weight=2) )
        moves.append( mvScale(sigma_b[i], weight=2) )
        moves.append( mvSlide(sigma_d[i], weight=2) )
        moves.append( mvSlide(sigma_b[i], weight=2) )
        if (use_rj) {
            moves.append( mvRJSwitch(sigma_d[i], weight=3) )
            moves.append( mvRJSwitch(sigma_b[i], weight=3) )
            use_sigma_d[i] := ifelse(sigma_d[i] == 0.0, 0, 1)
            use_sigma_b[i] := ifelse(sigma_b[i] == 0.0, 0, 1)
        }
    }
    for (i in 1:phi_e.size()) {
        moves.append( mvScale(phi_e[i], weight=2) )
        moves.append( mvScale(phi_w[i], weight=2) )
        moves.append( mvSlide(phi_e[i], weight=2) )
        moves.append( mvSlide(phi_w[i], weight=2) )
        if (use_rj) {
            moves.append( mvRJSwitch(phi_e[i], weight=3) )
            moves.append( mvRJSwitch(phi_w[i], weight=3) )
            use_phi_e[i] := ifelse(phi_e[i] == 0.0, 0, 1)
            use_phi_w[i] := ifelse(phi_w[i] == 0.0, 0, 1)
        }
    }
    for (i in 1:phi_d.size()) {
        moves.append( mvScale(phi_d[i], weight=2) )
        moves.append( mvScale(phi_b[i], weight=2) )
        moves.append( mvSlide(phi_d[i], weight=2) )
        moves.append( mvSlide(phi_b[i], weight=2) )   
     if (use_rj) {
            moves.append( mvRJSwitch(phi_d[i], weight=3) )
            moves.append( mvRJSwitch(phi_b[i], weight=3) )
            use_phi_d[i] := ifelse(phi_d[i] == 0.0, 0, 1)
            use_phi_b[i] := ifelse(phi_b[i] == 0.0, 0, 1)
        }
    }
} else {
    # set all feature effect parameters to zero;
    # do not add moves to update during MCMC
    for (i in 1:sigma_e.size()) {
        sigma_e[i].setValue(0.0)
        sigma_w[i].setValue(0.0)
    }
    for (i in 1:sigma_d.size()) {
        sigma_d[i].setValue(0.0)
        sigma_b[i].setValue(0.0)
    }
    for (i in 1:phi_e.size()) {
        phi_e[i].setValue(0.0)
        phi_w[i].setValue(0.0)
    }
    for (i in 1:phi_d.size()) {
        phi_d[i].setValue(0.0)
        phi_b[i].setValue(0.0)
    }
}


# molecular moves
if (use_mol) {
    
    # base rate of molecular substitutioni
    moves.append(mvScale(mu_mol_base, weight=5) )

    # branch rates of molecular substitution, centered on mu_mol_base
    for (i in 1:num_branches) {
        moves.append(mvScale(mu_mol_branch[i], weight=1))
    }

    for (i in 1:num_loci) {
        if (i >= 2) {
            moves.append(mvScale(mu_mol_locus_rel[i], weight=3))
        }
        moves.append(mvScale(kappa[i], weight=3))
        moves.append(mvScale(alpha[i], weight=3))
        moves.append(mvSimplex(pi_mol[i], alpha=3, offset=0.5, weight=3))
    }

    # joint moves
    up_down_scale_tree = mvUpDownScale(lambda=1.0, weight=20)
    up_down_scale_tree.addVariable(timetree,      up=true)
    up_down_scale_tree.addVariable(root_age,      up=true)
    up_down_scale_tree.addVariable(mu_mol_branch, up=false)
    up_down_scale_tree.addVariable(mu_mol_base,   up=false)
    moves.append(up_down_scale_tree)

    up_down_mol_rate = mvUpDownScale(lambda=1.0, weight=20)
    up_down_mol_rate.addVariable(mu_mol_branch, up=true)
    up_down_mol_rate.addVariable(mu_mol_base,   up=true)
    moves.append(up_down_mol_rate)

    # MJL: this seems to cause a bug, working to fix w/ Mike May
    rate_age_proposal = mvRateAgeProposal(timetree, weight=20, alpha=5)
    rate_age_proposal.addRates(mu_mol_branch)
    moves.append(rate_age_proposal)

}



############
# Monitors #
############

print("Creating monitors...")
# create monitor vector
monitors = VectorMonitors()
# screen monitor, so you don't get bored
monitors.append( mnScreen(root_age, printgen=print_gen) )
# file monitor for all simple model variables
monitors.append( mnModel(printgen=print_gen, file="output/" + analysis + ".model.txt") )
# file monitor for tree
monitors.append( mnFile(timetree, printgen=print_gen, file="output/" + analysis + ".tre") )
# file monitor for molecular model
if (use_mol) {
    monitors.append( mnFile(mu_mol_base, mu_mol_branch, mu_mol_locus_rel, alpha, kappa, root_age, printgen=print_gen, file="output/" + analysis + ".mol.txt") )
}
# file monitor for biogeographic model
for (k in 1:num_times) {
    bg_mon_filename = "output/" + analysis + ".time" + k + ".bg.txt"
    monitors.append( mnFile(filename = bg_mon_filename,printgen=print_gen,rho_e, rho_w, rho_d, rho_b, r_e[k], r_w[k], r_d[k][1], r_d[k][2], r_d[k][3], r_d[k][4], r_d[k][5], r_d[k][6], r_b[k][1], r_b[k][2], r_b[k][3], r_b[k][4], r_b[k][5], r_b[k][6], m_e[k][1], m_w[k][1], m_d[k][1], m_d[k][2], m_d[k][3], m_d[k][4], m_d[k][5], m_d[k][6], m_b[k][1], m_b[k][2], m_b[k][3], m_b[k][4], m_b[k][5], m_b[k][6]))
}
monitors.append( mnFile(filename="output/"+analysis+".param.json", printgen=print_gen, format="json",
                        rho_e, rho_w, rho_d, rho_b, r_e, r_w, r_d, r_b, m_e, m_w, m_d, m_b) )

# ancestral estimates
monitors.append( mnJointConditionalAncestralState(tree=timetree, glhbdsp=timetree, printgen=print_gen*stoch_print_gen, filename="output/" + analysis + ".states.txt", withTips=true, withStartStates=true, type="NaturalNumbers") ) 

#monitors.append( mnStochasticCharacterMap(glhbdsp=timetree, printgen=print_gen*10, filename="output/" + analysis + ".stoch.txt", use_simmap_default=false) )
# report any other summary statistics


# create model object
print("Creating model...")
mymodel = model(timetree)

# create MCMC object
print("Creating MCMC...")
mymcmc = mcmc(mymodel, moves, monitors, moveschedule=move_schedule)
mymcmc.operatorSummary()

# run MCMC
print("Running MCMC...")
mymcmc.run(n_iter, underPrior=under_prior)

# done!
quit()
