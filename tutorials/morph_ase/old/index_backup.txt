<!doctype html>
<html lang="en">
<link rel="icon" type="image/png" href="/assets/img/favicon.png" >
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="search-domain" value="https://revbayes.github.io/">
    <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/syntax.css">
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/main.css" />
    <title>RevBayes: Discrete Morphology Evolution</title>
  </head>
  <body>
    <div class="container">
      <nav class="navbar navbar-default navbar-fixed-top">
  <div class="container-fluid">
    <div class="navbar-header">
      <a href="/" class="pull-left">
        
        <img class="navbar-logo" src="/assets/img/aquabayes-desaturated.png" alt="RevBayes Home" />
        
      </a>

      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar" align="right"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

    </div>
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li><a href="/download">Download</a></li>
        <li><a href="/tutorials/">Tutorials</a></li>
        <li><a href="/documentation/">Documentation</a></li>
        <li><a href="https://revbayes.github.io/revscripter/">RevScripter</a></li>
        <li><a href="/workshops/">Workshops</a></li>
        <li><a href="/jobs/">Jobs</a></li>
        <li><a href="/developer/">Developer</a></li>
        <li><<a href="/gui">GUI</a></li>
      </ul>
      <!-- <form class="navbar-form navbar-right" role="search" id="search" onsubmit="google_search(); return false;">
        <div class="form-group">
          <input type="text" id="google-search" placeholder="Search..." aria-label="Google site search">
        </div>
      </form> -->
    </div>
  </div>
</nav>

      <div class="titlebar">
	<h1 class="maintitle">Discrete Morphology Evolution</h1>
	<h3 class="subtitle">Ancestral State Estimation, Testing for Irreversibility and Correlation between Characters</h3>
	<h4 class="authors">Sebastian Höhna</h4>
  <h5>Last modified on February 25, 2022</h5>
</div>


<div class="sidebar no-print">
<blockquote class="overview" id="overview">
  <h2>Overview</h2>
  
  <div class="row">
    <div class="col-md-9">
        <strong>Prerequisites</strong>
        
          <ul id="prerequisites">
          
            <li><a href="/tutorials/intro/">Getting Started with RevBayes and Rev Language Syntax</a></li>
          
            <li><a href="/tutorials/mcmc/">Introduction to Markov chain Monte Carlo (MCMC) Sampling</a></li>
          
            <li><a href="/tutorials/ctmc/">Nucleotide substitution models</a></li>
          
            <li><a href="/tutorials/morph_tree/">Discrete morphology - Tree Inference</a></li>
          
          </ul>
        
    </div>
  </div>
  
</blockquote>





</div>
<h2 class="section" id="introduction">Introduction</h2><hr class="section">

Discrete morphological models are not only useful for tree estimation,
as was done in Tutorial <a href="/tutorials/morph_tree/">Discrete morphology - Tree Inference</a>, but also to ask specific questions about the evolution of the morphological character of interest.
Specifically, there are a few types of analyses that we might be interest in.
First, we can test different models of morphological evolution,
such as reversible and irreversible models, and estimate rates under these models.
Using an irreversible model of evolution, we can test, for example,
for Dollo's law of a complex character that can be lost but not gained again <a class="citation" href="#Goldberg2008">(Goldberg and Igić 2008)</a>.

Additionally, we might be interest in ancestral state estimation,
or mapping transition on the phylogeny.
Commonly the central problem in statistical phylogenetics concerns *marginalizing* over all unobserved character histories that evolved along the branches of a given phylogenetic tree according to some model, $M$, under some parameters, $\theta$.
This marginalization yields the probability of observing the tip states, $X_\text{tip}$,
given the model and its parameters,
$P( X_\text{tip} | \theta, M ) = \sum_{X_\text{internal}} P( X_\text{internal}, X_\text{tip} \mid \theta, M )$.
One might also wish to find the probability distribution of ancestral state
configurations that are consistent with the tip state distribution,
$P( X_\text{internal} \mid X_\text{tip}, \theta, M )$, and to sample
ancestral states from that distribution.
This procedure is known as *ancestral state estimation*.

Finally, we might be interested in testing for correlated evolution between discrete morphological characters.
For example,

This tutorial will provide a discussion of modeling morphological characters
and ancestral state estimation, and will demonstrate how to perform such
Bayesian phylogenetic analysis using RevBayes <a class="citation" href="#Hoehna2016b">(Höhna et al. 2016)</a>.


<h2 class="section" id="sec_irreversible_matrix">Overview of Discrete Morphology Models: Unequal rate models and irreversible models</h2><hr class="section">

The instantaneous rate matrix encodes the transition rates between all pairs of evolutionary states.
It is important to emphasize that all rate matrices are assertions about how morphological evolution operates.
Depending on how one populates the rate matrix elements, different evolutionary hypotheses may be expressed.

When we model the evolution of morphological data, unlike nucleotide data, each change may require a sequence of intermediate changes.
Getting to one state may require going through another.
In short, it is probably not likely that one single model describes all characters well.


<h3 class="subsection" id="symmetric-unordered">Symmetric unordered</h3><hr class="subsection">

The standard Mk model of character evolution, where M denotes it is a Markov model and $K$ denotes the number of states for the character.
The lineage may transition directly from state 1 to state 4 without going through states 2 and 3, which is representative of a character with
*unordered* states.
In addition, all transition rates are equal as they are in the Jukes-Cantor rate matrix <a class="citation" href="#Jukes1969">(Jukes and Cantor 1969)</a>.
Here is an example of a symmetric unordered Mk model for $k=3$.

$$
Q = \begin{pmatrix}
- & r & r \\
r & - & r \\
r & r & -
\end{pmatrix}
$$


Define the single shared rate parameter
```
mu <- 1.0
```

Define the rates
```
rates := [ [0.0,  mu,  mu],
           [ mu, 0.0,  mu],
           [ mu,  mu, 0.0] ]
```

Create the rate matrix
```
Q := fnFreeK(rates)
Q
```
```
   [ [ -1.0000, 0.5000, 0.5000 ] ,
     0.5000, -1.0000, 0.5000 ] ,
     0.5000, 0.5000, -1.0000 ] ]
```
{:.Rev-output}


Now, let's compute the transition probability matrix for a branch length of 0.1.
```
P <- Q.getTransitionProbabilities(0.1)
P
```
```
[ [ 0.907, 0.046, 0.046 ],
  [ 0.046, 0.907, 0.046 ],
  [ 0.046, 0.046, 0.907 ] ]
```
{:.Rev-output}

If we believed that, for example, for a couple of states, some transitions are strongly
more likely, we could add a multiplier between those two states:
```
rates := [ [  0.0,  mu,   mu],
           [ 2*mu, 0.0, 2*mu],
           [   mu,  mu,   mu] ]
Q := fnFreeK(rates)
Q
```
```
   [ [ -0.8333, 0.4167, 0.4167 ] ,
     0.8333, -1.6667, 0.8333 ] ,
     0.4167, 0.4167, -0.8333 ] ]
```
{:.Rev-output}
```
 P <- Q.getTransitionProbabilities(0.1)
 P
```
```
   [ [ 0.922, 0.038, 0.040 ],
     [ 0.075, 0.850, 0.075 ],
     [ 0.040, 0.038, 0.922 ] ]
```
{:.Rev-output}

If we then get our transition probabilities, we see that this changes our probability of observing the not simply our two state transitions that we changed the rate for, but others as well.

This type of approach is common in parsimony, where it is one of several things referred to as weighted parsimony.
This approach to using different matrices requires you to, *a priori* specify your matrix.
But in reality, there is often fairly little guidance or information by which we decide if a weight applied to a transition is appropriate.
Biologists still use models of this type - the Dollo model, in which a character is assumed not to be able to re-evolve once lost, is an extreme version of penalizing one change.

Because the transition rates between all differing pairs of states are the same, so are the transition probabilities.
Similarly, the probability of remaining in any given state is also equal across states.



<h3 class="subsection" id="asymmetric-ordered">Asymmetric ordered</h3><hr class="subsection">

Character states that are ordered imply that evolutionary transitions occur in particular sequences.
For example, the number of digits on a foot might vary by gaining and losing single digits, meaning the transition from three to five digits cannot occur without going through the evolutionary state of possessing four digits.
Below, we assume that gain events ( $n \rightarrow n+1$ ) occur at rate $\lambda$ and loss events ($n \rightarrow n-1$) occur at rate $\mu$.
The zeroes indicate that there is no immediate evolutionary path between states $1$ and $4$: states $2$ and $3$ must be used to reach $4$ from $1$.

$$
Q = \begin{pmatrix}
- & \lambda & 0 & 0 \\
\mu & -   & \lambda & 0 \\
0 & \mu & -   & \lambda \\
0 & 0 & \mu & -
\end{pmatrix}
$$


Create two rate parameters, $\lambda$ for gain and $\mu$ loss events.

```
lambda ~ dnExponential( 1 )
mu ~ dnExponential( 1 )
lambda.setValue( 3 )
mu.setValue( 1 )
```

Create a tridiagonal matrix of transition rates, meaning state $i$ may only transition to states $i-1$ and $i+1$

```
diag_rates := [ [  0.0, lambda,    0.0,    0.0],
                [   mu,    0.0, lambda,    0.0],
                [  0.0,     mu,    0.0, lambda],
                [  0.0,    0.0,     mu,    0.0] ]
```

Create the rate matrix

```
Q := fnFreeK(diag_rates)
Q
```
```
[ [ -1.5385, 1.5385, 0.0000, 0.0000 ] ,
     0.5128, -2.0513, 1.5385, 0.0000 ] ,
     0.0000, 0.5128, -2.0513, 1.5385 ] ,
     0.0000, 0.0000, 0.5128, -0.5128 ] ]
```
{:.Rev-output}

Compute the transition probability matrix for a branch length of 0.1.

```
P <- Q.getTransitionProbabilities(rate=0.1)
P
```
```
[ [ 0.861, 0.129, 0.010, 0.001],
  [ 0.043, 0.821, 0.126, 0.010],
  [ 0.001, 0.042, 0.821, 0.136],
  [ 0.000, 0.001, 0.045, 0.954]]
```
{:.Rev-output}

Note that $P[1][2] > P[1][3] > P[1][4]$, primarily because those transitions require a minimum of one, two, and three events, respectively.
In addition, note that assigning asymmetric transition rates causes $P[1][2] > P[2][1]$ because $rates[1][2] > rates[2][1]$.



>In RevBayes we have also the specific rate matrix for this model: `fnOrderedRateMatrix(maxState, lambda, mu)`.
{:.instruction}



<h3 class="subsection" id="correlated-binary-characters">Correlated binary characters</h3><hr class="subsection">

Two characters do not necessarily evolve independently of one another.
Take two characters in plants: the presence or absence of toothed leaf margins (character X) is thought to be ecologically correlated with the presence of absence of leaf lobing (character Y).
For a single binary character, there are two states (0 and 1), but there are four states for a pair of non-independent binary characters (00, 10, 01, and 11).
(missing reference) introduced a general framework for modeling the evolution of joint sets of characters.
These models require that only one evolutionary event can occur in a moment of time, which is enforced with the 0 terms.
In addition, the transition rate that, say, character X goes from 0 to 1 depends on the current value of character Y.

<h4 class="subsubsection" id="seven-free-parameters">Seven free parameters</h4><hr class="subsubsection">

In the first case, all possible transitions might be assigned their own parameter.
Here, we'll assign a simplex over all rates, leaving seven free parameters (plus an eighth parameter that scales the rate matrix).

$$
Q = \begin{pmatrix}
                      - & \mu_{00 \rightarrow 10} & \mu_{00 \rightarrow 01} &                       0 \\
\mu_{10 \rightarrow 00} &                       - &                       0 & \mu_{10 \rightarrow 11} \\
\mu_{01 \rightarrow 00} &                       0 &                       - & \mu_{01 \rightarrow 11} \\
                      0 & \mu_{11 \rightarrow 10} & \mu_{11 \rightarrow 01} &                       - \\
\end{pmatrix}
$$

```
r ~ dnDirichlet( [1,1,1,1,1,1,1,1] )
r.setValue( simplex(1,1,3,3,3,3,1,1) )
```

Create an array of zeroes for the four states (00, 10, 01, 11)

```
for (i in 1:4) {
    for (j in 1:4) {
        rates[i][j] <- 0.0
    }
}
```

Populate the elements of `rates`

```
rates[1][2] := r[1] # 00->10
rates[1][3] := r[2] # 00->01
rates[2][1] := r[3] # 10->00
rates[2][4] := r[4] # 10->11
rates[3][1] := r[5] # 01->00
rates[3][4] := r[6] # 01->11
rates[4][2] := r[7] # 11->10
rates[4][3] := r[8] # 11->01
```

Create the rate matrix

```
Q := fnFreeK(rates)
Q
```
```
[ [ -0.6667, 0.3333, 0.3333, 0.0000 ] ,
     1.0000, -2.0000, 0.0000, 1.0000 ] ,
     1.0000, 0.0000, -2.0000, 1.0000 ] ,
     0.0000, 0.3333, 0.3333, -0.6667 ] ]
```
{:.Rev-output}

Compute the transition probability matrix for a branch length of 0.1.
```
P <- Q.getTransitionProbabilities(rate=0.1)
P
```
```
[ [ 0.938, 0.029, 0.029, 0.003],
  [ 0.088, 0.822, 0.003, 0.088],
  [ 0.088, 0.003, 0.822, 0.088],
  [ 0.003, 0.029, 0.029, 0.938] ]
```
{:.Rev-output}
Note that the probability of remaining in state 10 or state 01 is less than the probability of remaining in state 00 or state 11.
In this toy example, these probabilities reflect that states 10 an 01 are less evolutionarily stable than states 00 and 11.

<h4 class="subsubsection" id="four-free-parameters">Four free parameters</h4><hr class="subsubsection">

Alternatively, characters X and Y might share state frequencies, $\pi_j$, and transition rates $\mu_{ij}^{(k)}$, where $i$ is the starting state for the character undergoing change, $j$ is the ending state, and $k$ is the state of the other character.
This results in two stationary frequencies (one free parameter), four transition rates for $0 \rightarrow 1$ and $1 \rightarrow 0$ given that the other character is in state 0 or state 1 (three free parameters), plus one free parameter to scale the rate matrix.

$$
Q = \begin{pmatrix}
- & \mu_{01}^{(0)} \pi_1 \pi_0 & \mu_{01}^{(0)} \pi_0 \pi_1 & 0 \\
\mu_{10}^{(0)} \pi_0 \pi_0 & -   & 0 & \mu_{01}^{(1)} \pi_1 \pi_1 \\
\mu_{10}^{(0)} \pi_0 \pi_0 & 0   & - & \mu_{01}^{(1)} \pi_1 \pi_1 \\
0 & \mu_{10}^{(1)} \pi_1 \pi_0 & \mu_{10}^{(1)} \pi_0 \pi_1 & - \\
\end{pmatrix}
$$

Assign the stationary frequencies of being in state 0 or state 1 shared by both characters X and Y.
```
pi ~ dnDirichlet([1,1])
pi.setValue( simplex(1,3) )
```
Assign the relative transition rates for gain and loss provided that the other character is in state 0 or 1.
```
r ~ dnDirichlet( [1,1,1,1] )
r.setValue( simplex(1,3,3,1) )
```
Create an array of zeroes for the four states (00, 10, 01, 11)

```
for (i in 1:4) {
    for (j in 1:4) {
        rates[i][j] <- 0.0
    }
}
```
Populate the elements of {\tt rates}
```
rates[1][2] := r[1] * pi[2] * pi[1] # 00->10
rates[1][3] := r[1] * pi[1] * pi[2] # 00->01
rates[2][1] := r[3] * pi[1] * pi[1] # 10->00
rates[2][4] := r[2] * pi[2] * pi[2] # 10->11
rates[3][1] := r[2] * pi[1] * pi[1] # 01->00
rates[3][4] := r[3] * pi[2] * pi[2] # 01->11
rates[4][2] := r[4] * pi[2] * pi[1] # 11->10
rates[4][3] := r[4] * pi[1] * pi[2] # 11->01
```
Create the rate matrix
```
Q := fnFreeK(rates)
Q
```
```
[ [ -0.6333, 0.3167, 0.3167, 0.0000 ] ,
     0.4750, -2.3750, 0.0000, 1.9000 ] ,
     0.4750, 0.0000, -2.3750, 1.9000 ] ,
     0.0000, 0.3167, 0.3167, -0.6333 ] ]
```
{:.Rev-output}

Compute the transition probability matrix for a branch length of 0.1.
```
P <- Q.getTransitionProbabilities(0.1)
P
```
```
[ [ 0.940, 0.027, 0.027, 0.005],
  [ 0.041, 0.792, 0.003, 0.164],
  [ 0.041, 0.003, 0.792, 0.164],
  [ 0.001, 0.027, 0.027, 0.944] ]
```
{:.Rev-output}

Note that this model has a tendency towards state 11.
```
P_10 <- Q.getTransitionProbabilities(10.0)
P_10
```
```
[ [ 0.159, 0.105, 0.105, 0.630],
  [ 0.158, 0.105, 0.105, 0.632],
  [ 0.158, 0.105, 0.105, 0.632],
  [ 0.158, 0.105, 0.105, 0.632] ]
```
{:.Rev-output}


<h3 class="subsection" id="covarion">Covarion</h3><hr class="subsection">

Covarion models <a class="citation" href="#Tuffley1998">(Tuffley and Steel 1998)</a> capture the possibility that a ``hidden'' (unobserved or unmeasurable) states cause evolutionary processes to vary in tempo and modes.
For example, phylogenetically local clusters of plant lineages appear to transition between herbaceous and woody habits at relatively high rates, so one might want to quantify where these bursts occur <a class="citation" href="#Beaulieu2013">(Beaulieu et al. 2013)</a>.
While similar in structure to the correlated character model of <a class="citation" href="#Pagel1994">(Pagel 1994)</a>, covarion models do not observe the hidden state that induce the mode-shifts.
Instead, covarion models expand the character's state space by a factor of $K$, and observe the character once for each of the $K$ categories.
For example, take a binary character modeled with $K=2$ hidden state classes.
The model would treat a character that is observed as being in state 0 as possibly being in either of the $K=2$ classes (0,1) and (0,2).
In practice, this is done by setting the likelihood of observing those $0k$ states to equal 1.

The expanded structure of a simple covarion rate matrix with $K=2$ is

$$
Q = \left(
\begin{array}{cc|cc}
- & r_1 q_{01}^{(1)} & s_{12} & 0 \\
r_1 q_{10}^{(1)} & - & 0 & s_{12} \\
\hline
s_{21} & 0 & - & r_2 q_{01}^{(2)} \\
0 & s_{21} & r_2 q_{10}^{(2)} & -  \\

\end{array}
\right)    
$$

This form can be reduced to a simpler block-matrix representation
$$
Q = \left(
\begin{array}{c|c}
r_1 Q^{(1)} & s_{12} I  \\
\hline
s_{21} I & r_2 Q^{(2)} \\
\end{array}
\right)
$$


where $Q^{(i)}$ is the rate matrix for the $i$th class, $r_i \in r$ is the clock rate for the $i$th class, and $S$ is the rate matrix to switch between classes.
```
sr ~ dnDirichlet([1,1])
sr.setValue( simplex(1,2) )
switch_rates := [ [   0.0, sr[1] ],
                  [ sr[2],   0.0 ] ]
Q_switch := fnFreeK(switch_rates)
```

Create an array of zeroes for the four states (00, 10, 01, 11)
```
cr[1] ~ dnExp(1)
cr[2] ~ dnExp(1)
cr[1].setValue(3)
cr[2].setValue(1)
```

Populate the elements of `rates`
```
Q_class[1] := fnJC(2)

bf ~ dnDirichlet( [1,1] )
bf.setValue( simplex(1,3) )
Q_class[2] := fnF81( bf )
```

Create the rate matrix
```
Q := fnCovarionRateMatrix(Q=Q_class, switch_rates=Q_switch, clock_rates=cr)
Q
```
```
[ [ -1.1126, 0.8901, 0.2225, 0.0000 ] ,
     0.8901, -1.1126, 0.0000, 0.2225 ] ,
     0.4451, 0.0000, -1.0385, 0.5934 ] ,
     0.0000, 0.4451, 0.1978, -0.6429 ] ]
```
{:.Rev-output}

Compute the transition probability matrix for a branch length of 0.1.
```
P <- Q.getTransitionProbabilities(0.1)
P <- Q.getTransitionProbabilities(1)
P
```
```
[ [ 0.899, 0.080, 0.020, 0.002],
  [ 0.080, 0.899, 0.001, 0.020],
  [ 0.040, 0.003, 0.902, 0.055],
  [ 0.002, 0.041, 0.018, 0.939] ]
```
{:.Rev-output}

The rows and columns correspond to (in order): state 0 evolving by $r_1 Q^{(1)}$, state 1 evolving by $r_1 Q^{(1)}$, state 1 evolving by $r_2 Q^{(2)}$, and state 2 evolving by $r_2 Q^{(2)}$.
Note that $P[1][2] > P[3][4]$, which is largely due to the fact that $r_1 > r_2$.

<ol class="bibliography"><li><span id="Beaulieu2013">Beaulieu J.M., O’Meara B.C., Donoghue M.J. 2013. Identifying hidden rate changes in the evolution of a binary morphological character: the evolution of plant habit in campanulid angiosperms. Systematic Biology. 62:725–737.</span>

<a href="https://doi.org/10.1093/sysbio/syt034">10.1093/sysbio/syt034</a>

</li>
<li><span id="Goldberg2008">Goldberg E.E., Igić B. 2008. On Phylogenetic Tests of Irreversible Evolution. Evolution. 62:2727–2741.</span>

<a href="https://doi.org/10.1111/j.1558-5646.2008.00505.x">10.1111/j.1558-5646.2008.00505.x</a>

</li>
<li><span id="Hoehna2016b">Höhna S., Landis M.J., Heath T.A., Boussau B., Lartillot N., Moore B.R., Huelsenbeck J.P., Ronquist F. 2016. RevBayes: Bayesian Phylogenetic Inference Using Graphical Models and an Interactive Model-Specification Language. Systematic Biology. 65:726–736.</span>

<a href="https://doi.org/10.1093/sysbio/syw021">10.1093/sysbio/syw021</a>

</li>
<li><span id="Jukes1969">Jukes T.H., Cantor C.R. 1969. Evolution of Protein Molecules. Mammalian Protein Metabolism. 3:21–132.</span>

<a href="https://doi.org/10.1016/B978-1-4832-3211-9.50009-7">10.1016/B978-1-4832-3211-9.50009-7</a>

</li>
<li><span id="Pagel1994">Pagel M. 1994. Detecting correlated evolution on phylogenies: a general method for the comparative analysis of discrete characters. Proceedings of the Royal Society of London B: Biological Sciences. 255:37–45.</span>

<a href="https://doi.org/10.1098/rspb.1994.0006">10.1098/rspb.1994.0006</a>

</li>
<li><span id="Tuffley1998">Tuffley C., Steel M. 1998. Modeling the covarion hypothesis of nucleotide substitution. Mathematical Biosciences. 147:63–91.</span>

<a href="https://doi.org/10.1016/S0025-5564(97)00081-3">10.1016/S0025-5564(97)00081-3</a>

</li></ol>

<script type="text/javascript">
var _ol = document.querySelectorAll('ol');
for (var i = 0, elem_ol; elem_ol = _ol[i]; i++) {
	if ( elem_ol.classList == "bibliography" ) {
		var _li = elem_ol.getElementsByTagName("li");
		//for (var j = 0, elem_li; elem_li = _li[j]; j++)
		//{
		//	elem_li.innerHTML = elem_li.innerHTML.replace(/(https?:\/\/)([^\s<]+)/,"<a href=\"$1$2\">$2");
		//}
		if(_li.length > 0)
			elem_ol.outerHTML = "<h2 class='references'>References</h2><hr class='references'>"+elem_ol.outerHTML
	}
}
</script>

      <br>
<footer>
  <div class="container">
  <div class="row">
    <div class="col-sm-12" align="center">
      <a href="https://github.com/revbayes">GitHub</a> | <a href="/license">License</a> | <a href="/citation">Citation</a> | <a href="https://groups.google.com/forum/#!forum/revbayes-users">Users Forum</a>
    </div>
  </div>
  <br>
  </div>
</footer>

    </div>
    <script src="/assets/js/vendor/jquery.min.js"></script>
<script src="/assets/js/vendor/FileSaver.min.js"></script>
<script src="/assets/js/vendor/jszip.min.js"></script>
<script src="/assets/js/vendor/bootstrap.min.js"></script>

<script type="text/javascript">
// Add default language
$(":not(code).highlighter-rouge").each(function() {
  
  if( this.classList == "highlighter-rouge") {
    this.classList = "Rev highlighter-rouge";
  }
  
});
// $("code.highlighter-rouge").each(function() {
//   
//   if( this.classList == "highlighter-rouge") {
//       this.classList = "Rev highlighter-rouge";
//   }
//   
// });
</script>
<script type="text/javascript"
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEscapes: true
    }
    });
    MathJax.Hub.Queue(function () {
      $(".aside").each(function() {
          $("div .MathJax", this).hide();
      });
    });
</script>
<script src="/assets/js/base.js"></script>

  </body>
</html>
